"""
Lexer Generator
@author Jongmin Park (trip2eee@gmail.com)
@date 2023-06-07
"""

import enum
from src.lex.lex_parser import *
from src.lex.regex import *
import time

class LexState:
    ITEM_ID = 0
    def __init__(self):
        self.rules = []
        self.id = LexState.ITEM_ID
        LexState.ITEM_ID += 1

        self.shift = {}
        self.reduce = []

    def __str__(self):
        s = 'S' + str(self.id) + '\n'
        for r in self.rules:
            s += '  ' + str(r) + '\n'
        
        s += '  SHIFT\n'
        for key in self.shift:
            if self.shift[key] != -1:
                s += '  \'' + str(key) + '\' -> s' + str(self.shift[key]) + '\n'

        s += '  ACCEPT\n'
        for r in self.reduce:
            s += '  a' + str(r) + '\n'

        return s
    
    def __eq__(self, value: object) -> bool:        

        equal = True

        if len(self.rules) == len(value.rules):
            for idx_rule in range(len(self.rules)):
                if self.rules[idx_rule].symbol != value.rules[idx_rule].symbol:
                    equal = False
                    break
                
                if self.rules[idx_rule].string != value.rules[idx_rule].string:
                    equal = False
                    break

                if self.rules[idx_rule].mark != value.rules[idx_rule].mark:
                    equal = False
                    break

        else:
            equal = False

        return equal
            
class LexerGenerator:
    def __init__(self):
        self.states = []
        self.lex_parser = None
        self.terminals = []

    def open(self, lex_path):

        self.lex_parser = LexParser()
        self.lex_parser.open(lex_path)

        self.rules = self.lex_parser.rules
        self.list_terminals = []

        regex = RegEx()
        rule: Rule

        self.aug_rules = []

        for rule in self.rules:
            regex.set_pattern(rule.string)
            rule.pattern = regex.pattern
            
            aug_rules, _ = regex.augment_rules(regex.pattern)

            # append augmented rules
            for r in aug_rules:
                # duplication check
                exist = False
                for ext_r in self.aug_rules:
                    if RegExUtils.compare_symbols(r, ext_r):
                        exist = True

                if exist == False:
                    r.symbol = rule.symbol
                    r.accept_action = rule.accept_action
                    self.aug_rules.append(r)

        for r in self.aug_rules:
            print(RegExUtils.symbols_to_str(r))

        regex.list_patterns = self.aug_rules
        regex.find_terminals()

        print('Terminals')
        for t in regex.list_terminals:
            print(RegExUtils.symbol_to_str(t))
        print('')

        self.list_states = regex.create_states()

    def value_check(self, val):
        if val == '\n':
            return '\\n'
        elif val == '\t':
            return '\\t'
        else:
            return val

    def generate_code(self, file_path):

        INDENT1 = '    '
        INDENT2 = '        '
        INDENT3 = '            '

        module_name = file_path
        if module_name.endswith('.py'):
            module_name = module_name[:-3]
        lexer_table_path = module_name + '_table.py'
        f = open(lexer_table_path, 'w')
        f.write('"""\n')
        f.write('@fn {}\n'.format(file_path))
        f.write('@brief Lexer table generated by lexer_generator.py\n')

        cur_time = time.strftime('%Y-%m-%d %H:%M:%S')
        f.write('@date {}\n'.format(cur_time))
        f.write('"""\n')

        # generate state functions
        list_state_codes = []
        line = 'class Lexer:\n'
        list_state_codes.append(line)

        state: RegExState
        for state in self.list_states:
            line = ''
            line += INDENT1 + 'def state_{}(self, c):\n'.format(state.id)
            comment = str(state)
            comment = comment.replace('\n', '\n' + INDENT2 + '#')
            line += INDENT2 + '#' + comment + '\n'

            line += INDENT2 + "state = -1\n"

            idx_if = 0
            # Shift Forward condition
            cond: Pattern
            line += INDENT2 + '# Shift Forward\n'
            for cond in state.shift_forward:

                if idx_if == 0:
                    line += INDENT2 + 'if '
                else:
                    line += INDENT2 + 'elif '
                idx_if += 1

                if cond.type == PatternType.VALUE:
                    line += "('{}' == c):\n".format(self.value_check(cond.value))
                    line += INDENT3 + 'state = {}\n'.format(state.shift_forward[cond])

                elif cond.type == PatternType.NOT_VALUE:
                    line += "('{}' != c):\n".format(self.value_check(cond.value))
                    line += INDENT3 + 'state = {}\n'.format(state.shift_forward[cond])

                elif cond.type == PatternType.CLASS or cond.type == PatternType.OR:
                    child: Pattern
                    for idx, child in enumerate(cond.childs):
                        if idx > 0:
                            line += ' or '

                        if child.type == PatternType.VALUE:
                            line += "('{}' == c)".format(self.value_check(child.value))

                        elif child.type == PatternType.NOT_VALUE:
                            line += "('{}' != c)".format(self.value_check(child.value))

                        elif child.type == PatternType.RANGE:
                            line += "('{}' < c < '{}')".format(child.range_min, child.range_max)

                    line += ':\n'
                    line += INDENT3 + 'state = {}\n'.format(state.shift_forward[cond])


            # Shift Backward condition
            line += INDENT2 + '# Shift Backward\n'

            # Stay in the current state            
            gen_stay_cond = False

            for rule in state.list_rules:
                if rule.mark >= 1:
                    cur_symbol = rule.symbols[rule.mark-1]
                    if cur_symbol.count_max == -1:
                        gen_stay_cond = True
                        break

            if gen_stay_cond:
                line += INDENT2 + '# Stay in the current state\n'

                for rule in state.list_rules:
                    if rule.mark >= 1:
                        cond = rule.symbols[rule.mark-1]
                        if cond.count_max == -1:
            
                            if idx_if == 0:
                                line += INDENT2 + 'if '
                            else:
                                line += INDENT2 + 'elif '
                            idx_if += 1

                            if cond.type == PatternType.VALUE:
                                line += "('{}' == c):\n".format(self.value_check(cond.value))
                                line += INDENT3 + 'state = {}\n'.format(state.id)

                            elif cond.type == PatternType.NOT_VALUE:
                                line += "('{}' != c):\n".format(self.value_check(cond.value))
                                line += INDENT3 + 'state = {}\n'.format(state.id)

                            elif cond.type == PatternType.CLASS or cond.type == PatternType.OR:
                                child: Pattern
                                for idx, child in enumerate(cond.childs):
                                    if idx > 0:
                                        line += ' or '

                                    if child.type == PatternType.VALUE:
                                        line += "('{}' == c)".format(self.value_check(child.value))

                                    elif child.type == PatternType.NOT_VALUE:
                                        line += "('{}' != c)".format(self.value_check(child.value))

                                    elif child.type == PatternType.RANGE:
                                        line += "('{}' < c < '{}')".format(child.range_min, child.range_max)

                                line += ':\n'
                                line += INDENT3 + 'state = {}\n'.format(state.id)
                                
                if state.accept != -1:
                    line += INDENT2 + '# Accept\n'
                    indent = ''
                    if idx_if == 0:
                        indent = INDENT2
                        line += INDENT2
                    else:
                        indent = INDENT2
                        line += INDENT2 + 'else:'
                    idx_if += 1

                    rule_accept: RegExRule
                    rule_accept = self.aug_rules[state.accept]

                    accept_symbol = rule_accept.symbol
                    accept_action = rule_accept.accept_action

                    if accept_action != '':
                        accept_action = accept_action.replace('\n', '\n' + indent)
                        line += accept_action + '\n'
                    else:
                        line += accept_symbol + '\n'

                    line += indent + '    state = 0\n'

            line += INDENT2 + 'return state\n\n'

            list_state_codes.append(line)

        
        for line in list_state_codes:
            f.write(line)

        f.close()