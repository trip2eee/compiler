"""
Lexer Generator
@author Jongmin Park (trip2eee@gmail.com)
@date 2023-06-07
"""

import enum
from src.lex.lex_parser import *
from src.lex.regex import *
import time

class LexState:
    ITEM_ID = 0
    def __init__(self):
        self.rules = []
        self.id = LexState.ITEM_ID
        LexState.ITEM_ID += 1

        self.shift = {}
        self.reduce = []

    def __str__(self):
        s = 'S' + str(self.id) + '\n'
        for r in self.rules:
            s += '  ' + str(r) + '\n'
        
        s += '  SHIFT\n'
        for key in self.shift:
            if self.shift[key] != -1:
                s += '  \'' + str(key) + '\' -> s' + str(self.shift[key]) + '\n'

        s += '  ACCEPT\n'
        for r in self.reduce:
            s += '  a' + str(r) + '\n'

        return s
    
    def __eq__(self, value: object) -> bool:        

        equal = True

        if len(self.rules) == len(value.rules):
            for idx_rule in range(len(self.rules)):
                if self.rules[idx_rule].symbol != value.rules[idx_rule].symbol:
                    equal = False
                    break
                
                if self.rules[idx_rule].string != value.rules[idx_rule].string:
                    equal = False
                    break

                if self.rules[idx_rule].mark != value.rules[idx_rule].mark:
                    equal = False
                    break

        else:
            equal = False

        return equal
            
class LexerGenerator:
    def __init__(self):
        self.states = []
        self.lex_parser = None
        self.terminals = []

    def open(self, lex_path):

        self.lex_parser = LexParser()
        self.lex_parser.open(lex_path)

        self.rules = self.lex_parser.rules
        self.list_terminals = []

        regex = RegEx()
        rule: Rule

        self.aug_rules = []

        for rule in self.rules:
            regex.set_pattern(rule.string)
            rule.pattern = regex.pattern
            
            aug_rules, _ = regex.augment_rules(regex.pattern)

            # append augmented rules
            for r in aug_rules:
                # duplication check
                exist = False
                for ext_r in self.aug_rules:
                    if RegExUtils.compare_symbols(r, ext_r):
                        exist = True

                if exist == False:
                    r.symbol = rule.symbol
                    r.accept_action = rule.accept_action
                    self.aug_rules.append(r)

        for r in self.aug_rules:
            print(RegExUtils.symbols_to_str(r))

        regex.list_patterns = self.aug_rules
        regex.find_terminals()

        print('Terminals')
        for t in regex.list_terminals:
            print(RegExUtils.symbol_to_str(t))
        print('')

        self.list_states = regex.create_states()

    def value_check(self, val):
        if val == '\n':
            return '\\n'
        elif val == '\t':
            return '\\t'
        else:
            return val

    def generate_code(self, file_path):

        f = open('src/lex/lexer_template.py', 'r')
        lexer_template = f.read()
        f.close()

        INDENT1 = '    '
        INDENT2 = '        '
        INDENT3 = '            '
        INDENT4 = '                '

        module_name = file_path
        if module_name.endswith('.py'):
            module_name = module_name[:-3]
        

        file_comment = ''

        file_comment += '"""\n'
        file_comment += '@fn {}\n'.format(file_path)
        file_comment += '@brief Lexer table generated by lexer_generator.py\n'

        cur_time = time.strftime('%Y-%m-%d %H:%M:%S')
        file_comment += '@date {}\n'.format(cur_time)
        file_comment += '"""\n'

        lexer_template = lexer_template.replace('%FILE_COMMENT%', file_comment)

        definition = self.lex_parser.definition
        idx_start = definition.find('%{')
        idx_end = definition.find('%}')

        if idx_start != -1 and idx_end != -1 and idx_end > idx_start:
            lexer_template = lexer_template.replace('%DEFINITIONS%', definition[idx_start+2:idx_end])
        else:
            lexer_template = lexer_template.replace('%DEFINITIONS%', '')

        scan_body = ''
        idx_if = 0

        state: RegExState
        for state in self.list_states:
            if idx_if == 0:
                scan_body += INDENT3 + 'if {} == state:\n'.format(state.id)
            else:
                scan_body += INDENT3 + 'elif {} == state:\n'.format(state.id)
            idx_if += 1

            if state.id == 0:
                scan_body += INDENT4 + 'self.idx_start = self.idx_char - 1\n'
                scan_body += INDENT4 + 'self.idx_start_col = self.idx_col\n'
                scan_body += INDENT4 + 'self.idx_start_line = self.idx_line\n'
            scan_body += INDENT4 + 'state = self.state_{}(c)\n'.format(state.id)
                
        state_func = ''        

        state: RegExState
        for state in self.list_states:
            state_func += INDENT1 + 'def state_{}(self, c):\n'.format(state.id)
            comment = str(state)
            comment = comment.replace('\n', '\n' + INDENT2 + '#')
            state_func += INDENT2 + '#' + comment + '\n'

            state_func += INDENT2 + "state = 0\n"

            idx_if = 0
            # Shift Forward condition
            cond: Pattern
            if len(state.shift_forward) > 0:
                state_func += INDENT2 + '# Shift Forward\n'
            for cond in state.shift_forward:

                if idx_if == 0:
                    state_func += INDENT2 + 'if '
                else:
                    state_func += INDENT2 + 'elif '
                idx_if += 1

                if cond.type == PatternType.VALUE:
                    state_func += "('{}' == c):\n".format(self.value_check(cond.value))
                    state_func += INDENT3 + 'state = {}\n'.format(state.shift_forward[cond])

                elif cond.type == PatternType.NOT_VALUE:
                    state_func += "('{}' != c):\n".format(self.value_check(cond.value))
                    state_func += INDENT3 + 'state = {}\n'.format(state.shift_forward[cond])

                elif cond.type == PatternType.CLASS or cond.type == PatternType.OR:
                    child: Pattern
                    for idx, child in enumerate(cond.childs):
                        if idx > 0:
                            state_func += ' or '

                        if child.type == PatternType.VALUE:
                            state_func += "('{}' == c)".format(self.value_check(child.value))

                        elif child.type == PatternType.NOT_VALUE:
                            state_func += "('{}' != c)".format(self.value_check(child.value))

                        elif child.type == PatternType.RANGE:
                            state_func += "('{}' <= c <= '{}')".format(child.range_min, child.range_max)

                    state_func += ':\n'
                    state_func += INDENT3 + 'state = {}\n'.format(state.shift_forward[cond])


            # Shift Backward condition
            if len(state.shift_backward) > 0:
                state_func += INDENT2 + '# Shift Backward\n'

                for cond in state.shift_backward:

                    if idx_if == 0:
                        state_func += INDENT2 + 'if '
                    else:
                        state_func += INDENT2 + 'elif '
                    idx_if += 1

                    if cond.type == PatternType.VALUE:
                        state_func += "('{}' == c):\n".format(self.value_check(cond.value))
                        state_func += INDENT3 + 'state = {}\n'.format(state.shift_backward[cond])

                    elif cond.type == PatternType.NOT_VALUE:
                        state_func += "('{}' != c):\n".format(self.value_check(cond.value))
                        state_func += INDENT3 + 'state = {}\n'.format(state.shift_backward[cond])

                    elif cond.type == PatternType.CLASS or cond.type == PatternType.OR:
                        child: Pattern
                        for idx, child in enumerate(cond.childs):
                            if idx > 0:
                                state_func += ' or '

                            if child.type == PatternType.VALUE:
                                state_func += "('{}' == c)".format(self.value_check(child.value))

                            elif child.type == PatternType.NOT_VALUE:
                                state_func += "('{}' != c)".format(self.value_check(child.value))

                            elif child.type == PatternType.RANGE:
                                state_func += "('{}' <= c <= '{}')".format(child.range_min, child.range_max)

                        state_func += ':\n'
                        state_func += INDENT3 + 'state = {}\n'.format(state.shift_backward[cond])


            # Stay in the current state            
            gen_stay_cond = False

            for rule in state.list_rules:
                if rule.mark >= 1:
                    cur_symbol = rule.symbols[rule.mark-1]
                    if cur_symbol.count_max == -1:
                        gen_stay_cond = True
                        break

            if gen_stay_cond:
                state_func += INDENT2 + '# Stay in the current state\n'

                for rule in state.list_rules:
                    if rule.mark >= 1:
                        cond = rule.symbols[rule.mark-1]
                        if cond.count_max == -1:
            
                            if idx_if == 0:
                                state_func += INDENT2 + 'if '
                            else:
                                state_func += INDENT2 + 'elif '
                            idx_if += 1

                            if cond.type == PatternType.VALUE:
                                state_func += "('{}' == c):\n".format(self.value_check(cond.value))
                                state_func += INDENT3 + 'state = {}\n'.format(state.id)

                            elif cond.type == PatternType.NOT_VALUE:
                                state_func += "('{}' != c):\n".format(self.value_check(cond.value))
                                state_func += INDENT3 + 'state = {}\n'.format(state.id)

                            elif cond.type == PatternType.CLASS or cond.type == PatternType.OR:
                                child: Pattern
                                for idx, child in enumerate(cond.childs):
                                    if idx > 0:
                                        state_func += ' or '

                                    if child.type == PatternType.VALUE:
                                        state_func += "('{}' == c)".format(self.value_check(child.value))

                                    elif child.type == PatternType.NOT_VALUE:
                                        state_func += "('{}' != c)".format(self.value_check(child.value))

                                    elif child.type == PatternType.RANGE:
                                        state_func += "('{}' <= c <= '{}')".format(child.range_min, child.range_max)

                                state_func += ':\n'
                                state_func += INDENT3 + 'state = {}\n'.format(state.id)

            else_exists = False

            # handle cases in which minimum count=0 (?, {0}, {0,M})            
            for rule in state.list_rules:
                mark_symbol = rule.mark_symbol()

                if mark_symbol is not None and mark_symbol.count_min == 0:
                    state_func += INDENT2 + '# Handle minimum count=0 (?, {0}, {0,M})\n'

                    next_state_id = state.shift_forward[mark_symbol]

                    cond = mark_symbol

                    if idx_if == 0:
                        state_func += INDENT2 + '\n'
                    else:
                        state_func += INDENT2 + 'else:\n'
                    idx_if += 1

                    state_func += INDENT3 + 'state = {}\n'.format(next_state_id)
                    state_func += INDENT3 + 'self.unget_char()\n'.format(next_state_id)
                    else_exists = True
                    break

            if state.accept != -1:
                if else_exists == False:
                    state_func += INDENT2 + '# Accept\n'
                    indent = ''
                    indent2 = ''
                    if idx_if == 0:
                        indent = INDENT1
                    else:
                        indent = INDENT2
                        state_func += INDENT2 + 'else:\n'
                    
                    indent2 = indent + '    '
                    idx_if += 1

                    rule_accept: RegExRule
                    rule_accept = self.aug_rules[state.accept]

                    accept_symbol = rule_accept.symbol
                    accept_action = rule_accept.accept_action

                    state_func += indent2 + 'yytext = self.get_text()\n'
                    if accept_action != '':
                        accept_action = accept_action.replace('\n', '\n' + indent)
                        state_func += accept_action + '\n'
                    else:
                        state_func += indent2 + 'yytype = ' + accept_symbol + '\n'

                    state_func += indent2 + 'self.unget_char()\n'
                    state_func += indent2 + 'self.add_token(yytext, yytype)\n'
                    else_exists = True
                else:
                    print('ERROR: Accept Conflict in state {}!'.format(state.id))

            if else_exists == False:
                if idx_if > 0:                    
                    state_func += INDENT2 + 'else:\n'
                    state_func += INDENT3 + 'self.error_handler()\n'

            state_func += INDENT2 + 'return state\n\n'


        lexer_template = lexer_template.replace('%SCAN_BODY%', scan_body)
        lexer_template = lexer_template.replace('%STATE_FUNCTIONS%', state_func)
        # for state_func in list_state_codes:
        #     f.write(state_func)

        lexer_file_path = module_name + '.py'
        f = open(lexer_file_path, 'w')
        f.write(lexer_template)
        f.close()