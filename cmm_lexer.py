"""
@fn ./cmm_lexer.py
@brief Lexer table generated by lexer_generator.py
@date 2023-06-29 23:31:44
"""


# Definitions

COMMENT = 1
ID = 2
ASSIGN = 3
IF = 4
FOR = 5
PLUS = 6
MINUS = 7
LTE = 8
GTE = 9
EQUAL = 10
LT = 11
GT = 12


class Lexer:
    def __init__(self):        
        self.idx_char = 0
        self.idx_line = 0
        self.idx_col = -1
        self.idx_col_prev = -1
        self.idx_line_prev = -1

        self.idx_start = 0
        self.idx_start_col = 0
        self.idx_start_line = 0

        self.code = ''
        self.list_tokens = []
    
    def get_char(self):
        if self.idx_char < len(self.code):
            c = self.code[self.idx_char]

            self.idx_line_prev = self.idx_line
            self.idx_col_prev = self.idx_col

            self.idx_char += 1
            self.idx_col += 1

            # handle new line.
            if c == '\n':
                self.idx_line += 1
                self.idx_col = -1

            return c
        else:
            self.idx_char += 1
            return '\n'

    def unget_char(self):
        if self.idx_char > 0:
            self.idx_char -= 1

            self.idx_line = self.idx_line_prev
            self.idx_col = self.idx_col_prev            

    def get_text(self):
        return self.code[self.idx_start:self.idx_char-1]

    def add_token(self, yytext, yytype):
         print('{} - {} in {}:{}'.format(yytext, yytype, self.idx_start_line+1, self.idx_start_col+1))

    def error_handler(self):
        text = self.code[self.idx_start:self.idx_char]
        if text != '\n' and text != '\t' and text != ' ' and text != '':
            print("Unexpected Character: '{}' in {}:{}".format(text, self.idx_line+1, self.idx_col+1))

    def scan(self, file_path):
        
        f = open(file_path, 'r')
        if f is not None:
            self.code = f.read()
            f.close()
            self.__scan()
            return True
        else:
             return False

    def __scan(self):
        state = 0
        self.list_tokens = []
        while self.idx_char <= len(self.code):
            c = self.get_char()

            if 0 == state:
                self.idx_start = self.idx_char - 1
                self.idx_start_col = self.idx_col
                self.idx_start_line = self.idx_line
                state = self.state_0(c)
            elif 1 == state:
                state = self.state_1(c)
            elif 2 == state:
                state = self.state_2(c)
            elif 3 == state:
                state = self.state_3(c)
            elif 4 == state:
                state = self.state_4(c)
            elif 5 == state:
                state = self.state_5(c)
            elif 6 == state:
                state = self.state_6(c)
            elif 7 == state:
                state = self.state_7(c)
            elif 8 == state:
                state = self.state_8(c)
            elif 9 == state:
                state = self.state_9(c)
            elif 10 == state:
                state = self.state_10(c)
            elif 11 == state:
                state = self.state_11(c)
            elif 12 == state:
                state = self.state_12(c)
            elif 13 == state:
                state = self.state_13(c)
            elif 14 == state:
                state = self.state_14(c)
            elif 15 == state:
                state = self.state_15(c)
            elif 16 == state:
                state = self.state_16(c)
            elif 17 == state:
                state = self.state_17(c)
            elif 18 == state:
                state = self.state_18(c)

        
    def state_0(self, c):
        #S0
        #  0:  _/ / .{0} \n
        #  1:  _/ * .|\n{0} * /
        #  2:  _[_a-zA-Z] [_a-zA-Z0-9]{0}
        #  3:  _+
        #  4:  _-
        #  5:  _=
        #  6:  _= =
        #  7:  _= <
        #  8:  _> =
        #  9:  _<
        #  SHIFT FORWARD
        #    / -> 1
        #    [_a-zA-Z] -> 2
        #    + -> 3
        #    - -> 4
        #    = -> 5
        #    < -> 6
        #    > -> 7
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('/' == c):
            state = 1
        elif ('_' == c) or ('a' <= c <= 'z') or ('A' <= c <= 'Z'):
            state = 2
        elif ('+' == c):
            state = 3
        elif ('-' == c):
            state = 4
        elif ('=' == c):
            state = 5
        elif ('<' == c):
            state = 6
        elif ('>' == c):
            state = 7
        else:
            self.error_handler()
        return state

    def state_1(self, c):
        #S1
        #  0:  / _/ .{0} \n
        #  1:  / _* .|\n{0} * /
        #  SHIFT FORWARD
        #    / -> 8
        #    * -> 9
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('/' == c):
            state = 8
        elif ('*' == c):
            state = 9
        else:
            self.error_handler()
        return state

    def state_2(self, c):
        #S2
        #  2:  [_a-zA-Z] _[_a-zA-Z0-9]{0}
        #  SHIFT FORWARD
        #    [_a-zA-Z0-9]{0} -> 10
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('_' == c) or ('a' <= c <= 'z') or ('A' <= c <= 'Z') or ('0' <= c <= '9'):
            state = 10
        # Handle minimum count=0 (?, {0}, {0,M})
        else:
            state = 10
            self.unget_char()
        return state

    def state_3(self, c):
        #S3
        #  3:  +_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 3
        state = 0
        # Accept
        yytext = self.get_text()
        yytype = PLUS
        self.unget_char()
        self.add_token(yytext, yytype)
        return state

    def state_4(self, c):
        #S4
        #  4:  -_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 4
        state = 0
        # Accept
        yytext = self.get_text()
        yytype = MINUS
        self.unget_char()
        self.add_token(yytext, yytype)
        return state

    def state_5(self, c):
        #S5
        #  5:  =_
        #  6:  = _=
        #  7:  = _<
        #  SHIFT FORWARD
        #    = -> 11
        #    < -> 12
        #  SHIFT BACKWARD
        #  ACCEPT: 5
        state = 0
        # Shift Forward
        if ('=' == c):
            state = 11
        elif ('<' == c):
            state = 12
        # Accept
        else:
            yytext = self.get_text()
            yytype = ASSIGN
            self.unget_char()
            self.add_token(yytext, yytype)
        return state

    def state_6(self, c):
        #S6
        #  9:  <_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 9
        state = 0
        # Accept
        yytext = self.get_text()
        yytype = LT
        self.unget_char()
        self.add_token(yytext, yytype)
        return state

    def state_7(self, c):
        #S7
        #  8:  > _=
        #  SHIFT FORWARD
        #    = -> 13
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('=' == c):
            state = 13
        else:
            self.error_handler()
        return state

    def state_8(self, c):
        #S8
        #  0:  / / _.{0} \n
        #  SHIFT FORWARD
        #    .{0} -> 14
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('\n' != c):
            state = 14
        # Handle minimum count=0 (?, {0}, {0,M})
        else:
            state = 14
            self.unget_char()
        return state

    def state_9(self, c):
        #S9
        #  1:  / * _.|\n{0} * /
        #  SHIFT FORWARD
        #    .|\n{0} -> 15
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('\n' != c) or ('\n' == c):
            state = 15
        # Handle minimum count=0 (?, {0}, {0,M})
        else:
            state = 15
            self.unget_char()
        return state

    def state_10(self, c):
        #S10
        #  2:  [_a-zA-Z] [_a-zA-Z0-9]{0}_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 2
        state = 0
        # Stay in the current state
        if ('_' == c) or ('a' <= c <= 'z') or ('A' <= c <= 'Z') or ('0' <= c <= '9'):
            state = 10
        # Accept
        else:
            yytext = self.get_text()

        
            if yytext == 'if':
                yytype = IF
            elif yytext == 'for':
                yytype = FOR
            else:
                yytype = ID
        
            self.unget_char()
            self.add_token(yytext, yytype)
        return state

    def state_11(self, c):
        #S11
        #  6:  = =_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 6
        state = 0
        # Accept
        yytext = self.get_text()
        yytype = EQUAL
        self.unget_char()
        self.add_token(yytext, yytype)
        return state

    def state_12(self, c):
        #S12
        #  7:  = <_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 7
        state = 0
        # Accept
        yytext = self.get_text()
        yytype = LTE
        self.unget_char()
        self.add_token(yytext, yytype)
        return state

    def state_13(self, c):
        #S13
        #  8:  > =_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 8
        state = 0
        # Accept
        yytext = self.get_text()
        yytype = GTE
        self.unget_char()
        self.add_token(yytext, yytype)
        return state

    def state_14(self, c):
        #S14
        #  0:  / / .{0} _\n
        #  SHIFT FORWARD
        #    \n -> 16
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('\n' == c):
            state = 16
        # Stay in the current state
        elif ('\n' != c):
            state = 14
        else:
            self.error_handler()
        return state

    def state_15(self, c):
        #S15
        #  1:  / * .|\n{0} _* /
        #  SHIFT FORWARD
        #    * -> 17
        #  SHIFT BACKWARD
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('*' == c):
            state = 17
        # Stay in the current state
        elif ('\n' != c) or ('\n' == c):
            state = 15
        else:
            self.error_handler()
        return state

    def state_16(self, c):
        #S16
        #  0:  / / .{0} \n_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 0
        state = 0
        # Accept
        yytext = self.get_text()

        yytype = COMMENT
    
        self.unget_char()
        self.add_token(yytext, yytype)
        return state

    def state_17(self, c):
        #S17
        #  1:  / * .|\n{0} * _/
        #  SHIFT FORWARD
        #    / -> 18
        #  SHIFT BACKWARD
        #    .|\n{0} -> 15
        #  ACCEPT: -1
        state = 0
        # Shift Forward
        if ('/' == c):
            state = 18
        # Shift Backward
        elif ('\n' != c) or ('\n' == c):
            state = 15
        else:
            self.error_handler()
        return state

    def state_18(self, c):
        #S18
        #  1:  / * .|\n{0} * /_
        #  SHIFT FORWARD
        #  SHIFT BACKWARD
        #  ACCEPT: 1
        state = 0
        # Accept
        yytext = self.get_text()

        yytype = COMMENT
    
        self.unget_char()
        self.add_token(yytext, yytype)
        return state




